<!-- 0978e900-6e0d-4c84-8d7a-7e4ce3c02bb8 9cd10cf2-e7c5-4077-a8de-a73830f1ea64 -->
# Plan: Per-App Supervisor Access Codes

## 1. Data Model & Backend

- Update Firestore supervisor documents (e.g., `users/{supervisorId}`) to store per-app codes under `accessCodes[appId] = { code, updatedAt }`. Backfill existing supervisors via script/command.
- Extend supervisor assignment logic (where admins assign apps) so a 9-digit code is generated automatically for each newly assigned app. Use reusable helper (e.g., `generateAccessCode()` in `backend/src/auth` or a new service) to ensure uniqueness per app+code.
- Add admin-facing REST endpoints in NestJS (e.g., `POST /admin/supervisors/:id/codes/:appId/regenerate`) to allow regenerating a specific app code. Ensure it updates Firestore atomically and logs audit info.
- Implement public verification endpoint (e.g., `POST /public/check-access`) that accepts `{ code, app }`, validates against Firestore, enforces app/code match, and returns `{ valid, supervisorEmail }` without leaking extra data.

## 2. Admin/Supervisor UI Updates

- In the admin portal supervisor management page (file(s) e.g., `metavr-dashboard/src/app/admin/supervisors/[id]/page.tsx`), display each assigned app with its current access code and last-updated timestamp.
- Add “Regenerate code” button per app that hits the new backend endpoint and refreshes the UI state. Include confirmation prompts and success/error toasts.
- If there’s a supervisor self-service page, surface their per-app codes read-only so they can copy/share with operators.

## 3. Individual App Frontends (`apps/*/`)

- For each app (Card Matching, IQ Questions, etc.), add a lightweight gate component on `/config` (or the relevant entry point): a form requesting the 9-digit code.
- On submit, call the verification API with payload `{ code, app: '<app-id>' }`. When `valid: true`, store a short-lived flag (e.g., `sessionStorage.setItem('appAccessValidated', 'true')`) so the user isn’t prompted again during the session, then render the main config UI.
- Handle invalid responses with user-friendly errors and prevent access; optionally lock out after repeated failures.

## 4. Testing & Validation

- Unit: cover code generation helper, admin regenerate endpoint, and verification endpoint logic (happy path, invalid code, wrong app, regen).
- Integration: simulate admin assigning apps → codes generated, supervisor regen flow, and external app verifying codes.
- Manual: verify admin UI shows/regenerates codes, supervisor portal shows them, and both apps block/allow access based on the API response.

## 5. Security & Deployment

- Ensure verification endpoint enforces rate limiting / logging to prevent brute-force.
- Use HTTPS + proper CORS for external app requests. Document API contract for the game teams.
- Provide migration/backfill script instructions and admin communication for newly generated codes.

0) Quick conventions used below

### To-dos

- [ ] 0) Quick conventions used below
- [ ] Task 1.1 — Firestore structure
- [ ] Task 1.2 — generateAccessCode() helper
- [ ] Task 1.3 — Backfill / migration script
- [ ] Task 2.1 — Public verification endpoint
- [ ] Task 2.2 — Admin regenerate endpoint
- [ ] Task 3.1 — Admin portal: show codes
- [ ] Task 3.2 — Regenerate flow
- [ ] Task 3.3 — Supervisor self-service (optional)
- [ ] Task 4.1 — Add gate component on app config/entry
- [ ] Task 4.2 — Session short-lived flag
- [ ] Task 4.3 — Re-check on sensitive actions
- [ ] Cover unit/integration/manual tests